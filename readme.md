## 前言

在任何联网游戏中使用任何辅助工具都有封号的风险，此项目只是为了探讨学习 AHK 脚本在游戏中的可能应用场景，本人对于使用本工具造成的任何后果**概不负责**。

本人接触 AHK 比较晚，因此只大概学习了一下 V2 的语法，本项目中的所有代码都是基于 V2，如果想在 V1 中使用需要自行修改。

项目中的部分功能需要有一定的 AHK 脚本编辑经验，对于初学者可能不太友好。

## 文件结构

- parse.py：用于读取和改写 DAT 文件的 Python 脚本，主要用于搭配实现自动拾取功能。
- data：用于测试 parse.py 的演示文件。
- out：parse.py 脚本用于输出修改后 DAT 文件的输出目录。
- ahkv2：用于存储 ahk 辅助工具的脚本源码。该目录下的 main.ahk 就是工具主体，xpoe.ahk 则是我为 POE 专门定制的常用功能库，里面封装了许多制作 POE 辅助工具的常见功能模块。

## 功能介绍

我个人对于这种快捷键式的辅助工具一向秉持着能用就行的原则，所以除了参数设置界面会有几个通用的 GUI 界面外，其他可变参数都会以 txt 文件的形式修改保存。

部分工具需要读取装备的词条信息，本人使用的是流放编年史上的简体汉化，所以脚本中的代码也会以该汉化为准，使用其他文本补丁的话部分内容需要自行修改源码。为了使用方便，我将所有的快捷键都设置成了小键盘上的数字键，对于没有小键盘的设备需要自行修改相关快捷键设置。

我常年使用窗口模式玩 POE，因此只在窗口模式下对脚本进行了测试，全屏状态下是否可用无法保证，如遇 Bug 请尝试切换为窗口模式。

初次使用时需要将 ahkv2/config.json 文件**删除**，这是我的配置文件，每个人电脑分辨率不同，配置参数也各不相同。

### 功能零：按键拾取

2025 年了游戏内连个按键拾取功能都没有也是让人很无语，对于一个喜欢在国际服刷先驱升级的玩家来说，每次通货爆一地都很折磨，以前没有合成器和点势力传奇需求的时候都是过滤器往高了调，除了剥离破溃基本看不见啥，现在刷先驱如果不捡点小通货简直不知道在刷什么，只能说海平面上升了，在没有神圣石碎片的情况下先驱这种老机制的收益确实不够看了，除了无脑升级也没啥优势了。虽然可以使用鼠标连点器来缓解部分鼠标点击的压力，但是还不够彻底，终究有腱鞘炎的风险。就我生活中所见，绝大多数腱鞘炎都是高强度使用鼠标导致的，而因高强度使用键盘患上腱鞘炎的基本没听说过，这里建议大家玩游戏的时候能少点一下鼠标就尽量少点一下，防患于未然。

在不读内存的前提下，想要通过辅助程序实现自动拾取基本就只有截图后图像识别的路子了。AHK 自带的图像识别功能反应很慢，因此只能寻找其他反应更快的第三方库，目前主流的选择是 FindText，如果想要自己试试其他应用场景可以参考如下文章：

- [【应用】FindText + wincapture 结合使用（FeiYue） – AutoAHK](https://www.autoahk.com/archives/47248)
- [【函数】FindText 中文版 V2 版本 – AutoAHK](https://www.autoahk.com/archives/44766)
- [FindText 深度教程 v1.2 – AutoAHK](https://www.autoahk.com/archives/41636)

FindText 的基本逻辑是将目标图片根据灰度阈值转化为黑白图片，这样就可以通过简单的 0 和 1 来表示图片，进而将这些数字再转化为一段文本编码。因为过滤了部分处理起来复杂的颜色信息，所以在搜索速度上就能很快。

因为需要用到目标图片的文本表示来对屏幕截图进行搜索，所以本功能并不能开箱即用，毕竟每个人屏幕的分辨率以及所用的过滤器都不相同，怎么获取目标图片的文本表示这里不做讲解，B 站上搜索相关内容就能找到一堆视频教程，我只说一下怎么选择目标和获得文本后存储在哪里。

在开始截图之前需要先对过滤器进行编辑，确保所有需要自动拾取的物品的过滤器显示完全相同，包括字体大小、文本颜色、边框颜色等，到后期要捡的东西基本没啥，改一下过滤器还是挺快的。为了区分物品重要性的话可以允许存在两种样式，再多就不推荐了，会严重影响搜索速度。不会改过滤的朋友可以尝试一下[一乐过滤](https://filtereditor.cn/)，比较简单直观。

改好过滤器之后就可以正式开始截取目标图片了，需要提取所有待拾取目标的共同特征，一般是取其名称中的一个字，比如说“石”、“碎”等，但数量绝对不能多，四个目标的搜索时间基本就要达到 100 毫秒了，手感相较于两个以内的 40 毫秒已经差很多了。最优的方案其实是直接修改汉化文本，在所有的通货和装备名称前面添加一个“★”，这样在过滤器将物品分为高和低两种稀有度的情况下也只需要搜索两个“★”的图案即可。以编年史汉化为例，需要修改ROOT/Bundles2/data/traditional_chnese/baseitemtypes.datc64，可以使用[aianlinb/VisualGGPK2](https://github.com/aianlinb/VisualGGPK2)导出该文件后使用本项目中的 parse.py 脚本进行转化后替换原文件。

这里补充一点关于查价器的问题，一般查价器搜索的都是物品的英文名称，因此即使修改本地物品名称的汉化文本也不会影响查价器的使用，当然，如果修改了词缀文本，那就可能无法识别了。

获得几个目标图片的文本表示后，将它们按行粘贴到和 main.ahk 同目录下的 **collect.txt** 文件中即可，示例如下：

```
|<>*84$28.00M0001U00060000w0003k000D0001y0007s000TU003z03zzzzrzzzyDzzzkDzzw0TzzU0zzw01zzU03zw00Tzs01zzU07zy00zbw03wDk0D0D01s0S0700s0E00UU
|<>*160$28.00M0001U00060000w0003k000D0001y0007s000TU003z03zzzzrzzzyDzzzkDzzw0TzzU0zzw01zzU03zw00Tzs01zzU07zy00zbw03wDk0D0D01s0S0700s0E00UU
```

在实际搜索时会优先匹配第一行的目标，因此将稀有度较低的目标文本放在前面相对来说效率更高，搜索时间更短。

为了更省力，我将此功能的快捷键设为了空格，可根据个人需求修改源码，注意不要与游戏中原本的快捷键冲突即可。因为底层逻辑是截屏搜索，所以每次按键拾取之前需要先站定，毕竟搜索延迟最低也要几十毫秒。像先驱还有保险箱这类所有掉落物都在同一位置的情况，可以长按空格连续触发拾取动作，因为所有掉落都在一起，中间没有移动的过程，所以也就不会影响识别的准确性。如果电脑的性能较差，使用中发现拾取延迟过大，可以考虑修改源码中的相关语句，缩小搜索范围，将原本的全屏搜索改为部分区域搜索，只需要修改函数的第三到第六个参数，它们代表搜索区域的左上角点和右下角点的 x、y 坐标：

```ahk
ok := FindText(&x, &y, 0, 0, A_ScreenWidth, A_ScreenHeight, 0, 0, target0, 1, 0, , , , 9)
```

FindText 能够做到的事情还有很多，比如说识别左上角的角色状态栏，流血或者腐化之血图标出现后自动使用解除该状态的药剂，或者挂贪婪祭坛的时候自动选择非催灭的选项继续等，这些脚本写起来其实都非常简单，有兴趣的朋友可以自己试试，不会的话问问 AI，多试几次一般都能把大概功能写出来。

### 功能一：清空背包

打开仓库后按下小键盘 1 开始自动存包，按下 Ctrl+Num1 选择无视仓库偏好存包，按下 Ctrl+Alt+Num1 打开参数设置窗口，存包过程中可以长按 Num0 随时中止，后面那些功能的参数配置和中止快捷键与此类似，不再赘述。

### 功能二：10 个一组

快捷键为小键盘 2，功能就是把**背包中**化石之类二十个一组的通货分为两组，每组十个，主要是为了方便化石转换，部分稀有化石为十个一组。

### 功能三：庄园通货转换

快捷键为小键盘 3，启动前需要先打开庄园工艺台并选好对应的转换工艺，初次使用需要配置参数，首先是需要扫描的背包区域，然后是庄园工艺台上放置物品的位置，最后是转换按钮的位置，同时需要修改 cheap.txt 文件中的内容，按行填写自己**不想要**的通货名称，也就是那些**便宜**的通货。虽然理论上改为想要的物品更方便，但是出于稳定性和安全性的考量，还是选择了“如果是不想要的才转换”而不是“如果不是想要的就转换”。

我个人一般在赛季中期大家都开始用致密化石点胸甲之后开始转换，那时候一般 22 个致密化石就能换 1D，刷图刷累了就买点紫命能转换化石，紫命能 7000/D 左右时用浮士德把市面上所有单价 4 C 及以下的化石全部吃进，换成致密等高价化石后卖出，算是对金币利用率比较高的套现手法了。注意点就是用 D 收命能，用 D 卖致密，用 C 收化石，用 C 卖其他高价化石，以此形成 DC 流的循环，有时候没 C 了也可以这样操作一下，来个几次就有上千 C 了，刷累了当当操盘手也挺好玩的。

### 功能四：自动改造

快捷键为小键盘 4，这个是合成器出来之后写的，毕竟手动洗底子实在太折磨了，相信没人会喜欢。因为中途需要多次更换所用通货，所以最好搭配通货仓库使用，不然洗个二十次就要重新启动一遍。相较于手点一大好处就是可以充分利用增幅石，手点的时候都是 Shift 按住改造点到死，增幅石是绝对不可能点的。具体使用时除了配置通货和装备位置，还需要编辑 prefix.txt 和 suffix.txt 文件，在里面填上流放编年史中查到的目标词缀缩写，类似下面这种：

```
丰饶的
龙的
坚不可摧的
狱卒之
```

基本逻辑是只要出现这两个文件中的任一词缀，脚本就会自动停止并发出蜂鸣声，如果有空词缀则根据目标词缀的前后自动判断是否需要追加增幅石。

这赛季合成器大砍，建议就用来做做防装，武器啥的尽量不要考虑合成器，随便做一件五词装备就起码要用一仓库的底材和千万粉尘金币，我的评价是少折腾，不如点点破溃或者直接买。

功能三和功能四中的 txt 配置文件都支持热更新，可以在不重启脚本的情况下修改保存并生效，每次执行相关功能时都会重新读取 txt 文件。功能零为了追求低延迟，对应的 txt 配置文件必须提前载入内存，所以不支持热更新。

### 功能五：自动瓦图

快捷键为小键盘 5，在这两个赛季估计没啥人会用，我是为了打普通 8 MOD 城中广场保险箱策略刷法血卡写的，追求的就是一个安逸和惊喜感。具体功能就是把背包里所有的地图都自动变成 20 品质的腐化稀有地图，完成后会在剪贴板中置入过滤 8 MOD 地图的正则表达式方便筛选。

相较于用腐化制图甲虫掉落的 8 MOD 地图可以多 20 品质带来的额外数量，同时还有概率得到瓦尔密殿，根据我自己的统计，一般可以得到 20% 左右的有效地图。之前有看到说是把怪群数量洗到 25% 以上再瓦可以提高出 8 MOD 的概率，但我觉得没啥必要，反正地图也不贵，让脚本多瓦几批就是了。

## 编译问题

一般其实不推荐编译运行，但是如果想要分享给别人的话，编译过后记得将 ahkv2/lib/wincapture/64bit 以及 32bit 这两个文件夹复制一份到编译出来的 exe 文件的同级目录下，否则在启动时会报 dll 文件缺失的错误。

## DAT 文件数据格式

DAT 文件的结构非常简单，就是没有数据结构定义的相关数据的无头文件。打个比方，这类文件就相当于没有第一行表头的 CSV 表格，每一列都代表一个字段，它们所占的字节数都是相同的，每一行都代表一条记录，里面包含同一样事物的所有属性，这些属性由前面提到的字段构成。如果学过数据库相关知识的话理解起来就更加简单了，把它当成数据库中的一张表即可。

POE 中 DAT 文件中字段的常见数据类型有以下几种：

| 数据类型   | 所占字节 |
| ---------- | -------- |
| string     | 8        |
| foreignrow | 16       |
| i32        | 4        |
| enumrow    | 4        |
| bool       | 1        |
| row        | 8        |

想要解析一个 DAT 文件首先需要确定其数据头，这部分不需要自己从头开始，社区已经有人完成了相关工作，具体可以参考 [poe-tool-dev/dat-schema](https://github.com/poe-tool-dev/dat-schema)，该项目提供了 https://github.com/poe-tool-dev/dat-schema/releases/download/latest/schema.min.json 这一永久解析文件下载地址。

以 ROOT/Bundles2/data/traditional_chnese/baseitemtypes.datc64 文件的数据头为例：

```json
	{
      "validFor": 1,
      "name": "BaseItemTypes",
      "columns": [
        {
          "name": "Id",
          "description": null,
          "array": false,
          "type": "string",
          "unique": true,
          "localized": false,
          "references": null,
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "ItemClassesKey",
          "description": null,
          "array": false,
          "type": "foreignrow",
          "unique": false,
          "localized": false,
          "references": { "table": "ItemClasses" },
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "Width",
          "description": null,
          "array": false,
          "type": "i32",
          "unique": false,
          "localized": false,
          "references": null,
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "Height",
          "description": null,
          "array": false,
          "type": "i32",
          "unique": false,
          "localized": false,
          "references": null,
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "Name",
          "description": null,
          "array": false,
          "type": "string",
          "unique": false,
          "localized": true,
          "references": null,
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "InheritsFrom",
          "description": null,
          "array": false,
          "type": "string",
          "unique": false,
          "localized": false,
          "references": null,
          "until": null,
          "file": null,
          "files": [".ot", ".otc"],
          "interval": false
        },
        {
          "name": "DropLevel",
          "description": null,
          "array": false,
          "type": "i32",
          "unique": false,
          "localized": false,
          "references": null,
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "FlavourTextKey",
          "description": null,
          "array": false,
          "type": "foreignrow",
          "unique": false,
          "localized": false,
          "references": { "table": "FlavourText" },
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        {
          "name": "Implicit_ModsKeys",
          "description": null,
          "array": true,
          "type": "foreignrow",
          "unique": false,
          "localized": false,
          "references": { "table": "Mods" },
          "until": null,
          "file": null,
          "files": null,
          "interval": false
        },
        ...
        ...
      ],
      "tags": ["item:def", "item:droptable"]
    }
```

直接看可能不容易理解，可以使用 [SnosMe/poe-dat-viewer: Path of Exile .dat file viewer](https://github.com/SnosMe/poe-dat-viewer) 项目提供的网页工具 https://snosme.github.io/poe-dat-viewer 可视化查看，辅助理解。

前面提过，每一个字段所占的字节数是固定的，而 DAT 文件会按行依次存储表中的数据，因此我们只需要严格按照字节数一行一行的读取下去，就可以得到所有列的数据。当然，实际读取的时候没有这么简单，整个文件大体可以分为三部分。第一部分只占 4 个字节，用来记录表的行数，采用小端字节序存储，数据的低位字节内容保存在**低**地址处，后面所有的数字都采用小端字节序。第二部分就是一行一行的表格数据。第三部分用来存储表格中所有的变长数据。

表中的变长数据大致分为两种，第一种是最常见的 string，也就是字符串，第二部分中的 string 固定占据 8 个字节，一个汉字就需要占据 2 个字节，用这 8 个字节直接存储字符串肯定是不现实的，因此这里的 8 个字节存储的是该字符串存储在第三部分中的起始字节的索引。为了与第二部分有明确的分隔，第三部分开头的 0-7 个字节都为“\xbb”，因此变长数据实际上是从索引 8 开始存储的。此处使用的字符串编码格式比较特殊，是 UTF-16，这种编码统一采用 4 个字节表示 1 个字符，但对于大部分常用字符其开头两个字节都是“\xff\xfe”，因此在实际存储时每个字符只保存其后面两个字节，且会在字符串的末尾添加“\x00\x00\x00\x00”作为结束标识符。第二种是数组形式的 foreignrow，在数据头的定义中通过“array”属性值来确定。当“array”为 true 时，代表该外键是一对多的形式，该字段存储的就是数组形式的外键索引，与 string 类似的道理，最多 16 字节的 foreignrow 类型肯定是不可能存储任意变长数组的，因此这种数据类型的实际数据也会存储在文件的第三部分。此时 16 字节中的前 8 个字节用来存储数组中元素的数量，也就是数组长度，后 8 个用来存储起始索引。与 string 不同，在第三部分中的实际数据最后没有结束标识符，只需要将每个外键的 16 字节数据依次排列即可。

上面介绍的两种变长数据还有一点本质上的不同，对于 sting 而言，相同的字符串可以使用相同的起始索引，以此压缩文件体积，做到数据复用；而 foreignrow 则完全不同，即使是相同的数组也绝对不可以复用，而是需要单独存储，如果复用会导致游戏无法识别相关数据而闪退。

除了上述的三部分文件结构外，实际读取和保存 DAT 文件时还有几个小细节。首先是空值部分，数字类型的空值统一用“\xfe”填满所有位置；而空字符串则按照普通字符串处理，实际表现就是在文件第三部分存储一个“\x00\x00\x00\x00”，然后将所有空字符串的起始索引设为它；空数组前面 8 字节正常置为 0，后八位则是写为当前第三部分的索引值用于校验。至此 DAT 文件的结构以及相关的读写注意点就都讲解完毕了，具体实现可以参考代码示例。

## 后记

本项目的重点其实就是按键拾取功能的实现思路，其他几个功能只是顺便把我以前写的脚本整合了一下，因此目前比较主流的洗高数量 T17 或 T16.5 地图的功能并没有包含在内，有需要的朋友可以使用论坛内大佬分享的工具，或是参考本项目中的洗图代码自行 DIY。

最后吐槽一下流放之路，玩了这么多年游戏，这是唯一一款相关工具多到数不清，不屏蔽特效亮瞎眼，不使用辅助腱鞘炎，玩个游戏比上学还复杂的游戏，但是玩进去了那是真好玩，每次新版本云个 POB 都能玩半天，只希望以后不要真的变成赛年游戏。